---
const { title, subTitle, partners } = Astro.props;

interface Partner {
  icon: string;
  name?: string;
  href?: string;
}

interface Props {
  title: string;
  subTitle?: string;
  partners: Partner[];
}
---

<section
  class="mx-auto max-w-[85rem] px-4 py-10 sm:px-6 lg:px-8 lg:py-14 2xl:max-w-full"
>
  <!-- Title and description -->
  <div class="mx-auto mb-8 w-full space-y-1 text-center sm:w-1/2 lg:w-1/3">
    <h2
      class="text-2xl leading-tight font-bold text-balance text-neutral-800 sm:text-3xl dark:text-neutral-200"
    >
      {title}
    </h2>
    {
      subTitle && (
        <p class="leading-tight text-pretty text-neutral-600 dark:text-neutral-400">
          {subTitle}
        </p>
      )
    }
  </div>

  <!-- Scrolling Partner Logos -->
  <div class="relative overflow-hidden">
    <!-- Add a specific class ("scroll-track") for targeting in the script -->
    <div
      class="scroll-track animate-scroll flex gap-12 whitespace-nowrap will-change-transform"
    >
      {
        // Duplicate the partner list for a seamless loop.
        [...partners, ...partners].map((partner) => (
          <a
            href={partner.href}
            target="_blank"
            rel="noopener noreferrer"
            class="flex-shrink-0"
          >
            <img
              src={partner.icon}
              alt={partner.name || "Partner Logo"}
              class="h-24 w-auto rounded-xl duration-300 ease-in-out hover:scale-105"
              loading="lazy"
              decoding="async"
              onerror="this.onerror=null; this.src='/src/images/stilliconn.png';"
            />
          </a>
        ))
      }
    </div>
  </div>
</section>

<style>
  /* The animation will translate by the dynamic width of one partner set */
  .animate-scroll {
    animation: scrollLeft linear infinite;
  }

  @keyframes scrollLeft {
    0% {
      transform: translateX(0);
    }
    100% {
      /* Use the computed width to translate precisely one set of logos */
      transform: translateX(calc(-1 * var(--scroll-width)));
    }
  }
</style>

<!-- Inline JavaScript to measure width and update the animation duration -->
<script>
  // Function to update the CSS variable and animation duration
  function updateScrollAnimation() {
    const track = document.querySelector(".scroll-track");
    if (track) {
      // Since the list is duplicated, one copy occupies half of the total scrollWidth
      const contentWidth = track.scrollWidth / 2;
      if (contentWidth > 0) {
        // Set CSS variable for use in the keyframes (in pixels)
        document.documentElement.style.setProperty(
          "--scroll-width",
          `${contentWidth}px`
        );

        // Define your desired speed in pixels per second
        const speed = 40; // Adjust speed as needed
        // Compute the animation duration based on the width of one copy
        const duration = contentWidth / speed;
        (track as HTMLElement).style.animationDuration = duration + "s";
      }
    }
  }

  // Update after initial load and on window resize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', updateScrollAnimation);
  } else {
    updateScrollAnimation();
  }
  
  window.addEventListener("resize", updateScrollAnimation);
  
  // Retry after images load
  window.addEventListener("load", updateScrollAnimation);
</script>
